# 解析器的后续改进路线
## 下面可选
1. 宏程序解析代码重构。
2. 流水线减少级数，最终分为文件解析和算法两级，前者决定去哪里，后者决定怎么去。
3. 算法独立成库。
4. 不要再支持刀补后的精确断点继续，刀补归入算法，属于怎么去的问题。
5. 全面使用智能指针。
6. 内存池优化，可选tcmalloc或mimalloc。
7. Fifo的模应设置为2的n次方，这样能提升速度。
8. 寻址不加同步，用户可以自己选择加或不加。
9. 用门面模式封装解析器，使解析器具有整体感，且线程安全。
10. 去除用lua脚本组装解析器的代码。
11. 预分析去掉
12. batch批处理加工去掉

## 一些问题的澄清
一. 纤程，实际是一种有栈协程，目前并没有找到更好的替代方案。C++20的是无栈协程，所以不太合适。

MFL:[Fiber实际上约等于far jump，实现时是将当前执行环境保存，恢复执行时恢复执行环境。 **请问它具体有哪些问题** ？请列出来。可供使用的第三方库包括 boost、aco等等。by MFL]

答：目前存在的最大问题是，流水线存在系统性的内存泄漏和资源泄漏。Worker的编程者，以通常的编程知识来管理内存，往往不经意之间就已经造成了泄漏，发生以后还浑然不知，且即使发现存在泄漏，也极难排查。如果要避免问题产生，编程者需要掌握额外的知识，比如流水线的构成和原理、调用Read或Write后可能上下文无法切回等，这些都是流水线的实现细节，本应被封装起来，而不是成为使用者的负担。
早前已经完成了前期改造，也就是纤程并不会被粗暴的切出而不回，而是会以异常的方式退出，这样如果再配合智能指针的全面使用，理论上就可以避免泄漏问题的发生。智能指针作为一种约束加到编程者身上是值得的，一是它本身就能极大提高安全性，是很优秀的设计，二是它的特征十分明显，方便代码检查。

MFL: [1、请问现在是否有在Worker中编码的注意事项文档？作为生产，如果没有更好的技术手段，通过培训，让大家掌握这样的技能，也是一个办法。
2、不知道现在用的智能指针是 unique_ptr还是shared_ptr，后者需要单独的空间保存引用计数，会调用new分配内存，这在实时任务下算是一个需要注意的地方。by MFL]

答：1.已经有过培训了，关于智能指针的所有权概念以及它的使用建议。2.我建议在没有特殊要求情况下，默认使用unique_ptr，unique_ptr已经可以解决大多数问题，且它保证资源的所有者对象始终只有一个。share_ptr不太建议使用，首先它不是一个零成本抽象（unique_ptr是），其次，它的使用难度上比unique_ptr高，除非特殊情况下，需要共享所有权，比如多线程共享指针所有权，一般不要使用。

二. lua真的很重。ncex格式不仅文件本身，背后还有大量的代码都是由lua写成的，这些代码不在刀路中，却被刀路引用。所以不太能去除。

MFL:[不追求全部去掉LUA，但要确保在实时任务中不能有lua，考虑将Parser与Interp分为两个线程，在parser中允许有Lua，输出NcCode，在Interp中不可以有Lua。by MFL]

答：lua的作用，我一直以为是C++代码的延申，它用来负责变化最频繁、定制化程度最高的那部分业务比较合适，因为它可以不经过编译就完成改变。而相对稳定的代码都应该编译成二进制，也就是由C++来完成。目前，lua主要存在与解析器前端也就是Parser的部分以及toc，算法用到lua的地方应该仅限于参数的读取。可去掉的lua大致有：channel组装流水线的代码，参数传递的代码等。
关于Parser与Interp分为两个线程，个人是非常赞同的。首先这里已经提出了两个关键概念，就和我的提出的“解析决定去哪里，算法决定怎么去”相吻合，这两部分哪天如果真的解耦了，能解决大多数问题。其次，两者如果不在一个线程里，或许真的是更好的选择，毕竟两个线程对算力的压榨更加充分，这样似乎流水线都不用存在了。

MFL:[1、参数模型值得商榷；
2、在任务准备或收尾阶段（只要是不在任务中）不反对使用Lua。by MFL]

答：1.读参用lua问题问题不大。2.目前，在任务中，也是有lua的，解析中一些指令的行为，比如换刀，各个产品的换刀可能是不一样的，平台无法决定，所以就放在lua里实现，让产品线可以自己定制。但是Interp中是没有与lua互动的地方。

三. 解析和执行加工，不太能保证实时性，即使是把fifo设置为最小。

MFL:[在其他条件满足的情况下，从推的模式改为拉的模式，可以实现无缓存同时功能块之间解耦,by MFL]

答:个人理解，站在生产者角度，推是主动产生数据，而拉是被动产生数据。消费者如果需要一个NcStep，那么他向生产者提要求，也就是调用一个接口，生产者进入下一行的解析与计算，但这一次计算，并不会正好只产生一个NcStep，而会产生一组NcStep，所以还是需要一个缓冲区存放多余的数据。而在这些数据被消耗殆尽之前，生产者是闲着还是再生产？如果考虑实时性，就停下来，如果考虑效率，那么就继续生产。假如选择后者，和推模型其实没区别了，即使选择前者，也只能保证有一定的实时性，但也不会完全一致的。
以上是个人拙见，仅供参考。

MFL:[1、CNC要能稳定、周期性地、有节制地输出数据，而非神经刀一样，一会儿输出一堆，一会儿一个也没有。因此，各个worker在拉的模式下，产生一个数据后就通过协程切换将任务调度到后一级。
2、周期性地触发“拉”的行为，数据发送与数据生产之间的时序可设计。by MFL]

答：如果说各级worker不发生前瞻，其实是可以做到平稳产生数据的。那么以消费者为导向的拉模型，实际上可以做到消费者调用一次，就产生下一个周期